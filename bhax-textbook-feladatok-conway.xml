<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <para> Megoldás forrása: <link xlink:href=""/>
            <link
                xlink:href="https://gitlab.com/puskasmate/bhax/tree/master/thematic_tutorials/bhax_textbook/Conway/Hangya"
            /></para>
        <para> A hangyaszimulációs program tulajdonképpen mozó pontokat fog ábrázolni, amely egy
            hangyacsoport mozgására hasonlít. A projekteben 6 forráskód szerepel.</para>
        <para><emphasis role="bold"
            >ant.h</emphasis><programlisting>class Ant
{

public:
    int x;
    int y;
    int dir;

    Ant(int x, int y): x(x), y(y) {
        
        dir = qrand() % 8;
        
    }

};

typedef std::vector&lt;Ant> Ants;

#endif
</programlisting></para>
        <para>Az "ant.h" header-ben a hangya objektumok vannak definiálva. A hangyák viselkedése
            került lefordításra programozói nyelvre. A hangyáknak van pozíciójuk, ezt mi adjuk meg,
            illetve van irányuk, amit maguknak választanak ki. Valamint, hogy az ilyen típusú
            objektumokat "Ant" néven tároljuk.</para>
        <para><emphasis role="bold"
            >antthread.h</emphasis><programlisting>#ifndef ANTTHREAD_H
#define ANTTHREAD_H

#include &lt;QThread>
#include "ant.h"

class AntThread : public QThread
{
    Q_OBJECT

public:
    AntThread(Ants * ants, int ***grids, int width, int height,
             int delay, int numAnts, int pheromone, int nbrPheromone, 
             int evaporation, int min, int max, int cellAntMax);
    
    ~AntThread();
    
    void run();
    void finish()
    {
        running = false;
    }

    void pause()
    {
        paused = !paused;
    }

    bool isRunnung()
    {
        return running;
    }

private:
    bool running {true};
    bool paused {false};
    Ants* ants;
    int** numAntsinCells;
    int min, max;
    int cellAntMax;
    int pheromone;
    int evaporation;
    int nbrPheromone;
    int ***grids;
    int width;
    int height;
    int gridIdx;
    int delay;
    
    void timeDevel();

    int newDir(int sor, int oszlop, int vsor, int voszlop);
    void detDirs(int irany, int&amp; ifrom, int&amp; ito, int&amp; jfrom, int&amp; jto );
    int moveAnts(int **grid, int row, int col, int&amp; retrow, int&amp; retcol, int);
    double sumNbhs(int **grid, int row, int col, int);
    void setPheromone(int **grid, int row, int col);

signals:
    void step ( const int &amp;);

};

#endif
</programlisting></para>
        <para>Ebben a header-ben deklaráljuk az AntThread osztályt. Ez az osztály rendelkezni fog
            mindennel, amivel a QThread rendelkezik. Ez az osztály felelős a hangyák számításaiért.
            Deklarálunk benne egy run(), egy finish(), egy pause() és egy isRunning() függvényt. A
            finish a running értékét állítja hamisra, a pause a paused értékét negálja, az isRunning
            pedig visszaadja a running értékét. A private után deklaráljuk az összes változót,
            amelyekre a AntThread-nek szüksége van.</para>
        <para><emphasis role="bold"
            >antwin.h</emphasis><programlisting>#ifndef ANTWIN_H
#define ANTWIN_H

#include &lt;QMainWindow>
#include &lt;QPainter>
#include &lt;QString>
#include &lt;QCloseEvent>
#include "antthread.h"
#include "ant.h"

class AntWin : public QMainWindow
{
    Q_OBJECT

public:
    AntWin(int width = 100, int height = 75,
           int delay = 120, int numAnts = 100,
           int pheromone = 10, int nbhPheromon = 3,
           int evaporation = 2, int cellDef = 1,
           int min = 2, int max = 50,
           int cellAntMax = 4, QWidget *parent = 0);

    AntThread* antThread;

    void closeEvent ( QCloseEvent *event ) {

        antThread->finish();
        antThread->wait();
        event->accept();
    }

    void keyPressEvent ( QKeyEvent *event )
    {

        if ( event->key() == Qt::Key_P ) {
            antThread->pause();
        } else if ( event->key() == Qt::Key_Q
                    ||  event->key() == Qt::Key_Escape ) {
            close();
        }

    }

    virtual ~AntWin();
    void paintEvent(QPaintEvent*);

private:

    int ***grids;
    int **grid;
    int gridIdx;
    int cellWidth;
    int cellHeight;
    int width;
    int height;
    int max;
    int min;
    Ants* ants;

public slots :
    void step ( const int &amp;);

};

#endif
</programlisting></para>
        <para>Ez a header is osztályok meghívásával keződidk. A QMainWindow osztály fogja a
            szimuláció számára létrehozni az ablakot. A QPainter miatt a kirajzolás valósulhat meg,
            a QString a karakterláncokat fogja kezelni, a QCloseEvent pedig a kilépésért felelős,
            valamint meghívjuk a fentebb látható 2 headert. Átadjuk az AntWin osztályt, és a
            konstruktor illetve a destruktor mellett egy paintEvent nevű függvényt is deklarálunk. A
            keyPressEvent függvényt az ablak bezárása és a szimuláció szüneteltetése miatt szükséges
            deklarálnunk. A Q valamint az Escape billentyű megnyomásával bezárhatjuk az ablakot, a P
            billentyű egnyomásával pedig szüneteltethetjük a szimulációt. A private részben a
            szokásos változókat deklaráljuk. Végezetül egy új slotot deklarálunk step néven.</para>
        <para><emphasis role="bold"
            >antwin.cpp</emphasis><programlisting>#include "antwin.h"
#include &lt;QDebug>
</programlisting></para>
        <para>A szükséges header-ök meghívásával
            kezdünk.<programlisting>AntWin::AntWin ( int width, int height, int delay, int numAnts,
                 int pheromone, int nbhPheromon, int evaporation, int cellDef,
                 int min, int max, int cellAntMax, QWidget *parent ) : QMainWindow ( parent )
{
    setWindowTitle ( "Ant Simulation" );

    this->width = width;
    this->height = height;
    this->max = max;
    this->min = min;

    cellWidth = 6;
    cellHeight = 6;

    setFixedSize ( QSize ( width*cellWidth, height*cellHeight ) );

    grids = new int**[2];
    grids[0] = new int*[height];
    for ( int i=0; i&lt;height; ++i ) {
        grids[0][i] = new int [width];
    }
    grids[1] = new int*[height];
    for ( int i=0; i&lt;height; ++i ) {
        grids[1][i] = new int [width];
    }

    gridIdx = 0;
    grid = grids[gridIdx];

    for ( int i=0; i&lt;height; ++i )
        for ( int j=0; j&lt;width; ++j ) {
            grid[i][j] = cellDef;
        }

    ants = new Ants();

    antThread = new AntThread ( ants, grids, width, height, delay, numAnts, pheromone,
                                nbhPheromon, evaporation, min, max, cellAntMax);

    connect ( antThread, SIGNAL ( step ( int) ),
              this, SLOT ( step ( int) ) );

    antThread->start();

}
</programlisting></para>
        <para>A konstruktorban megadjuk az ablak nevét, méreteit, és beállítjuk, hogy mekkora legyen
            egy cella. A grids tömbben beállítjuk a rácsokat. Létrehozunk egy AntThread-et antThred
            néven. A connect fügvénnyel összekötjük a step slottal az előbb létrehozott
            antThread-et, majd a start függvény segítségével elindítjuk a
            folyamatot.<programlisting>void AntWin::paintEvent ( QPaintEvent* )
{
    QPainter qpainter ( this );

    grid = grids[gridIdx];

    for ( int i=0; i&lt;height; ++i ) {
        for ( int j=0; j&lt;width; ++j ) {

            double rel = 255.0/max;

            qpainter.fillRect ( j*cellWidth, i*cellHeight,
                                cellWidth, cellHeight,
                                QColor ( 255 - grid[i][j]*rel,
                                         255,
                                         255 - grid[i][j]*rel) );

            if ( grid[i][j] != min )
            {
                qpainter.setPen (
                    QPen (
                        QColor ( 255 - grid[i][j]*rel,
                                 255 - grid[i][j]*rel, 255),
                        1 )
                );

                qpainter.drawRect ( j*cellWidth, i*cellHeight,
                                    cellWidth, cellHeight );
            }



            qpainter.setPen (
                QPen (
                    QColor (0,0,0 ),
                    1 )
            );

            qpainter.drawRect ( j*cellWidth, i*cellHeight,
                                cellWidth, cellHeight );

        }
    }

    for ( auto h: *ants) {
        qpainter.setPen ( QPen ( Qt::black, 1 ) );

        qpainter.drawRect ( h.x*cellWidth+1, h.y*cellHeight+1,
                            cellWidth-2, cellHeight-2 );

    }

    qpainter.end();
}
</programlisting></para>
        <para>A paintEvent függvény kiszínezi az ablakot. A hangyák színe a fekete
            lesz.<programlisting>AntWin::~AntWin()
{
    delete antThread;

    for ( int i=0; i&lt;height; ++i ) {
        delete[] grids[0][i];
        delete[] grids[1][i];
    }

    delete[] grids[0];
    delete[] grids[1];
    delete[] grids;

    delete ants;
}
</programlisting></para>
        <para>Fentebb látható a destruktor, amely törli az antThread-et és a rácsokat, valamint a
            hangyákat.</para>
        <programlisting>void AntWin::step ( const int &amp;gridIdx )
{

    this->gridIdx = gridIdx;
    update();
}
</programlisting>
        <para>A step függvény pedig folyamatosan átállítja a gridIdx aktuális értékét, és az update
            függvény segítségével az ablakot is mindig frissíti.</para>
        <para><emphasis role="bold"
            >antthread.cpp</emphasis><programlisting>AntThread::AntThread ( Ants* ants, int*** grids,
                     int width, int height,
                     int delay, int numAnts, 
                     int pheromone, int nbrPheromone, 
                     int evaporation,
                     int min, int max, int cellAntMax)
{
    this->ants = ants;
    this->grids = grids;
    this->width = width;
    this->height = height;
    this->delay = delay;
    this->pheromone = pheromone;
    this->evaporation = evaporation;
    this->min = min;
    this->max = max;
    this->cellAntMax = cellAntMax;
    this->nbrPheromone = nbrPheromone;

    numAntsinCells = new int*[height];
    for ( int i=0; i&lt;height; ++i ) {
        numAntsinCells[i] = new int [width];
    }

    for ( int i=0; i&lt;height; ++i )
        for ( int j=0; j&lt;width; ++j ) {
            numAntsinCells[i][j] = 0;
        }

    qsrand ( QDateTime::currentMSecsSinceEpoch() );

    Ant h {0, 0};
    for ( int i {0}; i&lt;numAnts; ++i ) {

        h.y = height/2 + qrand() % 40-20;
        h.x = width/2 + qrand() % 40-20;

        ++numAntsinCells[h.y][h.x];

        ants->push_back ( h );

    }

    gridIdx = 0;
}
</programlisting></para>
        <para>A header-ök meghívása után fentebb látható a konstruktor. Itt értékadás történik,
            valamint a hangyák szétosztása a
            rácsokon.<programlisting>double AntThread::sumNbhs ( int **grid, int row, int col, int dir )
{
    double sum = 0.0;

    int ifrom, ito;
    int jfrom, jto;

    detDirs ( dir, ifrom, ito, jfrom, jto );

    for ( int i=ifrom; i&lt;ito; ++i )
        for ( int j=jfrom; j&lt;jto; ++j )

            if ( ! ( ( i==0 ) &amp;&amp; ( j==0 ) ) ) {
                int o = col + j;
                if ( o &lt; 0 ) {
                    o = width-1;
                } else if ( o >= width ) {
                    o = 0;
                }

                int s = row + i;
                if ( s &lt; 0 ) {
                    s = height-1;
                } else if ( s >= height ) {
                    s = 0;
                }

                sum += (grid[s][o]+1)*(grid[s][o]+1)*(grid[s][o]+1);

            }

    return sum;
}
</programlisting></para>
        <para>A sumNbhs (sumNeighborhoods) ahogy a nevében van, összeszámolja, hogy egy adoott
            cellának hány szomszédja
            van.<programlisting>int AntThread::newDir ( int sor, int oszlop, int vsor, int voszlop )
{

    if ( vsor == 0 &amp;&amp; sor == height -1 ) {
        if ( voszlop &lt; oszlop ) {
            return 5;
        } else if ( voszlop > oszlop ) {
            return 3;
        } else {
            return 4;
        }
    } else if ( vsor == height - 1 &amp;&amp; sor == 0 ) {
        if ( voszlop &lt; oszlop ) {
            return 7;
        } else if ( voszlop > oszlop ) {
            return 1;
        } else {
            return 0;
        }
    } else if ( voszlop == 0 &amp;&amp; oszlop == width - 1 ) {
        if ( vsor &lt; sor ) {
            return 1;
        } else if ( vsor > sor ) {
            return 3;
        } else {
            return 2;
        }
    } else if ( voszlop == width &amp;&amp; oszlop == 0 ) {
        if ( vsor &lt; sor ) {
            return 7;
        } else if ( vsor > sor ) {
            return 5;
        } else {
            return 6;
        }
    } else if ( vsor &lt; sor &amp;&amp; voszlop &lt; oszlop ) {
        return 7;
    } else if ( vsor &lt; sor &amp;&amp; voszlop == oszlop ) {
        return 0;
    } else if ( vsor &lt; sor &amp;&amp; voszlop > oszlop ) {
        return 1;
    }

    else if ( vsor > sor &amp;&amp; voszlop &lt; oszlop ) {
        return 5;
    } else if ( vsor > sor &amp;&amp; voszlop == oszlop ) {
        return 4;
    } else if ( vsor > sor &amp;&amp; voszlop > oszlop ) {
        return 3;
    }

    else if ( vsor == sor &amp;&amp; voszlop &lt; oszlop ) {
        return 6;
    } else if ( vsor == sor &amp;&amp; voszlop > oszlop ) {
        return 2;
    }

    else { //(vsor == sor &amp;&amp; voszlop == oszlop)
        qDebug() &lt;&lt; "ZAVAR AZ EROBEN az iranynal";

        return -1;
    }

}
</programlisting></para>
        <para>A newDir függvény egy hangya számára egy új irány kiosztásáért
            felelős.<programlisting>void AntThread::detDirs ( int dir, int&amp; ifrom, int&amp; ito, int&amp; jfrom, int&amp; jto )
{

    switch ( dir ) {
    case 0:
        ifrom = -1;
        ito = 0;
        jfrom = -1;
        jto = 2;
        break;
    case 1:
        ifrom = -1;
        ito = 1;
        jfrom = 0;
        jto = 2;
        break;
    case 2:
        ifrom = -1;
        ito = 2;
        jfrom = 1;
        jto = 2;
        break;
    case 3:
        ifrom =
            0;
        ito = 2;
        jfrom = 0;
        jto = 2;
        break;
    case 4:
        ifrom = 1;
        ito = 2;
        jfrom = -1;
        jto = 2;
        break;
    case 5:
        ifrom = 0;
        ito = 2;
        jfrom = -1;
        jto = 1;
        break;
    case 6:
        ifrom = -1;
        ito = 2;
        jfrom = -1;
        jto = 0;
        break;
    case 7:
        ifrom = -1;
        ito = 1;
        jfrom = -1;
        jto = 1;
        break;

    }

}
</programlisting></para>
        <para>A detDirs megvizsgálja egy hangya mozgásának irányát, és ez alapján a lehetséges
            útvonalakat állapítja
            meg.<programlisting>int AntThread::moveAnts ( int **racs,
                           int sor, int oszlop,
                           int&amp; vsor, int&amp; voszlop, int dir )
{

    int y = sor;
    int x = oszlop;

    int ifrom, ito;
    int jfrom, jto;

    detDirs ( dir, ifrom, ito, jfrom, jto );

    double osszes = sumNbhs ( racs, sor, oszlop, dir );
    double random = ( double ) ( qrand() %1000000 ) / ( double ) 1000000.0;
    double gvalseg = 0.0;


    for ( int i=ifrom; i&lt;ito; ++i )
        for ( int j=jfrom; j&lt;jto; ++j )
            if ( ! ( ( i==0 ) &amp;&amp; ( j==0 ) ) )
            {
                int o = oszlop + j;
                if ( o &lt; 0 ) {
                    o = width-1;
                } else if ( o >= width ) {
                    o = 0;
                }

                int s = sor + i;
                if ( s &lt; 0 ) {
                    s = height-1;
                } else if ( s >= height ) {
                    s = 0;
                }

                //double kedvezo = std::sqrt((double)(racs[s][o]+2));//(racs[s][o]+2)*(racs[s][o]+2);
                //double kedvezo = (racs[s][o]+b)*(racs[s][o]+b);
                //double kedvezo = ( racs[s][o]+1 );
                double kedvezo = (racs[s][o]+1)*(racs[s][o]+1)*(racs[s][o]+1);

                double valseg = kedvezo/osszes;
                gvalseg += valseg;

                if ( gvalseg >= random ) {

                    vsor = s;
                    voszlop = o;

                    return newDir ( sor, oszlop, vsor, voszlop );

                }

            }

    qDebug() &lt;&lt; "ZAVAR AZ EROBEN a lepesnel";
    vsor = y;
    voszlop = x;

    return dir;
}
</programlisting></para>
        <para>A moveAnts függvény, mint azt a neve is mutatja a hangyák mozgatásáért
            felelős.<programlisting>void AntThread::timeDevel()
{

    int **racsElotte = grids[gridIdx];
    int **racsUtana = grids[ ( gridIdx+1 ) %2];

    for ( int i=0; i&lt;height; ++i )
        for ( int j=0; j&lt;width; ++j ) 
        {
            racsUtana[i][j] = racsElotte[i][j];

            if ( racsUtana[i][j] - evaporation >= 0 ) {
                racsUtana[i][j] -= evaporation;
            } else {
                racsUtana[i][j] = 0;
            }

        }

    for ( Ant &amp;h: *ants ) 
    {

        int sor {-1}, oszlop {-1};
        int ujirany = moveAnts( racsElotte, h.y, h.x, sor, oszlop, h.dir );

        setPheromone ( racsUtana, h.y, h.x );

        if ( numAntsinCells[sor][oszlop] &lt;cellAntMax ) {

            --numAntsinCells[h.y][h.x];
            ++numAntsinCells[sor][oszlop];

            h.x = oszlop;
            h.y = sor;
            h.dir = ujirany;
            
        }
    }

    gridIdx = ( gridIdx+1 ) %2;
}
</programlisting></para>
        <para>A timeDevel függvény az összes hangya mozgásáért felelős, a gridIdx változó értékét
            változtatja folyamatosan. A mozgatás 2 rácson történik, az egyik rács a régi, az új rács
            pedig a régi alapján jön létre, ugyanis az új helyzeteket itt tároljuk a régiek
            felhasználásával.<programlisting>void AntThread::setPheromone ( int **racs,
                         int sor, int oszlop )
{

    for ( int i=-1; i&lt;2; ++i )
        for ( int j=-1; j&lt;2; ++j )    
            if ( ! ( ( i==0 ) &amp;&amp; ( j==0 ) ) ) 
            {
                int o = oszlop + j;
                {
                    if ( o &lt; 0 ) {
                        o = width-1;
                    } else if ( o >= width ) {
                        o = 0;
                    }
                }
                int s = sor + i;
                {
                    if ( s &lt; 0 ) {
                        s = height-1;
                    } else if ( s >= height ) {
                        s = 0;
                    }
                }

                if ( racs[s][o] + nbrPheromone &lt;= max ) {
                    racs[s][o] += nbrPheromone;
                } else {
                    racs[s][o] = max;
                }


            }

    if ( racs[sor][oszlop] + pheromone &lt;= max ) {
        racs[sor][oszlop] += pheromone;
    } else {
        racs[sor][oszlop]  = max;
    }

}
</programlisting></para>
        <para>A setPheromone függvény beállítja a feromonokat az aktuális
            cellán.<programlisting>void AntThread::run()
{
    running = true;
    while ( running ) {

        QThread::msleep ( delay );

        if ( !paused ) {
            timeDevel();
        }

        emit step ( gridIdx );

    }

}
</programlisting></para>
        <para>A run függvény a folyamat futásáért felelős. A timeDevel függvény is meghívásra kerül
            benne, így felfüggesztheti egyszerre az összes hangya
            mozgását.<programlisting>AntThread::~AntThread()
{
    for ( int i=0; i&lt;height; ++i ) {
        delete [] numAntsinCells[i];
    }

    delete [] numAntsinCells;
}
</programlisting></para>
        <para>A destruktorban a hangyákat tároló tömb elemeit egyesével töröljük, amint a hangyákat
            kitöröltük, eltávolítjuk a hangyákat tároló tömböt is.</para>
        <para><emphasis role="bold"
            >main.cpp</emphasis><programlisting>#include &lt;QApplication>
#include &lt;QDesktopWidget>
#include &lt;QDebug>
#include &lt;QDateTime>
#include &lt;QCommandLineOption>
#include &lt;QCommandLineParser>

#include "antwin.h"

/*
 * 
 * ./myrmecologist -w 250 -m 150 -n 400 -t 10 -p 5 -f 80 -d 0 -a 255 -i 3 -s 3  -c 22
 *
 */

int main ( int argc, char *argv[] )
{

    QApplication a ( argc, argv );

    QCommandLineOption szeles_opt ( {"w","szelesseg"}, "Oszlopok (cellakban) szama.", "szelesseg", "200" );
    QCommandLineOption magas_opt ( {"m","magassag"}, "Sorok (cellakban) szama.", "magassag", "150" );
    QCommandLineOption hangyaszam_opt ( {"n","hangyaszam"}, "Hangyak szama.", "hangyaszam", "100" );
    QCommandLineOption sebesseg_opt ( {"t","sebesseg"}, "2 lepes kozotti ido (millisec-ben).", "sebesseg", "100" );
    QCommandLineOption parolgas_opt ( {"p","parolgas"}, "A parolgas erteke.", "parolgas", "8" );
    QCommandLineOption feromon_opt ( {"f","feromon"}, "A hagyott nyom erteke.", "feromon", "11" );
    QCommandLineOption szomszed_opt ( {"s","szomszed"}, "A hagyott nyom erteke a szomszedokban.", "szomszed", "3" );
    QCommandLineOption alapertek_opt ( {"d","alapertek"}, "Indulo ertek a cellakban.", "alapertek", "1" );
    QCommandLineOption maxcella_opt ( {"a","maxcella"}, "Cella max erteke.", "maxcella", "50" );
    QCommandLineOption mincella_opt ( {"i","mincella"}, "Cella min erteke.", "mincella", "2" );
    QCommandLineOption cellamerete_opt ( {"c","cellameret"}, "Hany hangya fer egy cellaba.", "cellameret", "4" );
    QCommandLineParser parser;

    parser.addHelpOption();
    parser.addVersionOption();
    parser.addOption ( szeles_opt );
    parser.addOption ( magas_opt );
    parser.addOption ( hangyaszam_opt );
    parser.addOption ( sebesseg_opt );
    parser.addOption ( parolgas_opt );
    parser.addOption ( feromon_opt );
    parser.addOption ( szomszed_opt );
    parser.addOption ( alapertek_opt );
    parser.addOption ( maxcella_opt );
    parser.addOption ( mincella_opt );
    parser.addOption ( cellamerete_opt );

    parser.process ( a );

    QString szeles = parser.value ( szeles_opt );
    QString magas = parser.value ( magas_opt );
    QString n = parser.value ( hangyaszam_opt );
    QString t = parser.value ( sebesseg_opt );
    QString parolgas = parser.value ( parolgas_opt );
    QString feromon = parser.value ( feromon_opt );
    QString szomszed = parser.value ( szomszed_opt );
    QString alapertek = parser.value ( alapertek_opt );
    QString maxcella = parser.value ( maxcella_opt );
    QString mincella = parser.value ( mincella_opt );
    QString cellameret = parser.value ( cellamerete_opt );

    qsrand ( QDateTime::currentMSecsSinceEpoch() );

    AntWin w ( szeles.toInt(), magas.toInt(), t.toInt(), n.toInt(), feromon.toInt(), szomszed.toInt(), parolgas.toInt(),
                  alapertek.toInt(), mincella.toInt(), maxcella.toInt(),
                  cellameret.toInt() );

    w.show();

    return a.exec();
}
</programlisting></para>
        <para>A szükséges header-ök meghívása, valamint a megfelelő osztályok hozzáadása után "a"
            néven létrehozunk egy QApplication példányt. Ez lesz a konstruktor, melynek paraméterei
            az argc és argv lesznek. Ezután a lehetséges kapcsolókat adjuk meg. Ezután az "a"
            alapján egy parsert hozunk létre. Ehhez ismét hozzáadjuk a lehetséges kapcsolókat,
            valamint egy help és egy version lehetőséget. Ezután a process függvény segít
            feldolgozni az "a" adatait, majd eltárolja ezeket QString-ekbe. Véletlenszámok
            előállításával egy AntWin objektumot állítunk elő, melyre "w" néven tudunk hivatkozni. A
            show függvénnyel megmutatjuk a felhasználónak az ablakot. Láthatjuk, hogy a programunk
            az "a"-nak az exec függvény által módosított értékét adja vissza, amely a q lenyomásakor
            tér vissza.</para>            
    </section>        
    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>Forrás: <link
                xlink:href="https://gitlab.com/puskasmate/bhax/tree/master/thematic_tutorials/bhax_textbook/Conway/Hangya2"
            /></para>
        <para>
            <emphasis role="bold">sejtszal.h
            </emphasis><programlisting>#ifndef SEJTSZAL_H
#define SEJTSZAL_H

#include &lt;QThread>
#include "sejtablak.h"

class SejtAblak;

class SejtSzal : public QThread
{
    Q_OBJECT

public:
    SejtSzal(bool ***racsok, int szelesseg, int magassag,
             int varakozas, SejtAblak *sejtAblak);
    ~SejtSzal();
    void run();

protected:
    bool ***racsok;
    int szelesseg, magassag;
    // Megmutatja melyik rács az aktuális: [rácsIndex][][]
    int racsIndex;
    // A sejttér két egymást követő t_n és t_n+1 diszkrét időpillanata
    // közötti valós idő.
    int varakozas;
    void idoFejlodes();
    int szomszedokSzama(bool **racs,
                        int sor, int oszlop, bool allapot);
    SejtAblak* sejtAblak;

};

#endif // SEJTSZAL_H
</programlisting></para>
        <para>A "sejtszal.h" header-ben a SejtAblak osztályt fogjuk deklarálni. Ez az osztály ismét
            a QThread adataival fog rendelkezni. A public részben deklarájuk a konstruktort valamint
            a destruktort, továbbá a run() függvényt. A protected részben pedig a konstruktor által
            kért változókat deklarájuk. Egy 3 dimenziós racsok tömböt, a szélesség és magasság
            értékét, a racsIndex változót, mely az aktuális rácsot mutatja meg, egy varakozás
            változót, egy időfejlődés függvényt, valamint a szomszédok számának meghatározására egy
            függvényt, és egy sejtablak típusú pointert.</para>
        <para><emphasis role="bold"
            >sejtablak.h</emphasis><programlisting>#ifndef SEJTABLAK_H
#define SEJTABLAK_H

#include &lt;QMainWindow>
#include &lt;QPainter>
#include "sejtszal.h"

class SejtSzal;

class SejtAblak : public QMainWindow
{
  Q_OBJECT
  
public:
  SejtAblak(int szelesseg = 100, int magassag = 75, QWidget *parent = 0);

  ~SejtAblak();
  // Egy sejt lehet élő
  static const bool ELO = true;
  // vagy halott
  static const bool HALOTT = false;
  void vissza(int racsIndex);
  
protected:
  // Két rácsot használunk majd, az egyik a sejttér állapotát
  // a t_n, a másik a t_n+1 időpillanatban jellemzi.
  bool ***racsok;
  // Valamelyik rácsra mutat, technikai jellegű, hogy ne kelljen a
  // [2][][]-ból az első dimenziót használni, mert vagy az egyikre
  // állítjuk, vagy a másikra.
  bool **racs;
  // Megmutatja melyik rács az aktuális: [rácsIndex][][]
  int racsIndex;
  // Pixelben egy cella adatai.
  int cellaSzelesseg;
  int cellaMagassag;
  // A sejttér nagysága, azaz hányszor hány cella van?
  int szelesseg;
  int magassag;    
  void paintEvent(QPaintEvent*);
  void siklo(bool **racs, int x, int y);
  void sikloKilovo(bool **racs, int x, int y);
  
private:
  SejtSzal* eletjatek;
  
};

#endif // SEJTABLAK_H
</programlisting></para>
        <para>A sejtszal.h mellett további osztályokat hívunk meg. A sejtszal segítségével
            deklaráljuk a sejtablak nevű osztályt. Egy sejt lehet élő, vagy halott, ezen állapot
            eldöntését egy bool típusú változóban tároljuk, és deklarálunk egy "vissza" nevű void
            típusú függvényt. A protected rész magyarázata fentebb található kommentként sorról
            sorra. Az utolsó 3 függvény 3 rajzoló függvény. A private részben egy SejtSzal típusú
            pointert deklarálunk.</para>
        <para><emphasis role="bold"
            >sejtablak.cpp</emphasis><programlisting>SejtAblak::SejtAblak(int szelesseg, int magassag, QWidget *parent)
: QMainWindow(parent)
{
  setWindowTitle("A John Horton Conway-féle életjáték");
  
  this->magassag = magassag;
  this->szelesseg = szelesseg;

  
  cellaSzelesseg = 6;
  cellaMagassag = 6;

  setFixedSize(QSize(szelesseg*cellaSzelesseg, magassag*cellaMagassag));
  
  racsok = new bool**[2];
  racsok[0] = new bool*[magassag];
  for(int i=0; i&lt;magassag; ++i)
    racsok[0][i] = new bool [szelesseg];
  racsok[1] = new bool*[magassag];
  for(int i=0; i&lt;magassag; ++i)
    racsok[1][i] = new bool [szelesseg];

  racsIndex = 0;
  racs = racsok[racsIndex];

  // A kiinduló racs minden cellája HALOTT
  for(int i=0; i&lt;magassag; ++i)
    for(int j=0; j&lt;szelesseg; ++j)
      racs[i][j] = HALOTT;
    // A kiinduló racsra "ELOlényeket" helyezünk
    //siklo(racs, 2, 2);

    sikloKilovo(racs, 5, 60);

  eletjatek = new SejtSzal(racsok, szelesseg, magassag, 120, this);

  eletjatek->start();
  
}
</programlisting></para>
        <para>Itt látható a konstruktor. Itt történik az ablak nevének és méreteinek, valamint a
            cellák méreteinek beállítása. Létrehozunk két rácsot, fel is töltjük ezeket halott
            sejtekkel, majd a rajzoló függvények segítségével rajzolhatunk az ablakba. Egy SejtSzal
            típusú objektumot is létrehozunk a fentebb látható paraméterekkel, majd a start függvény
            meghívásával elindul a
            folyamat.<programlisting>void SejtAblak::paintEvent(QPaintEvent*) {
  QPainter qpainter(this);
  
  // Az aktuális
  bool **racs = racsok[racsIndex];
  // racsot rajzoljuk ki:
  for(int i=0; i&lt;magassag; ++i) { // végig lépked a sorokon
    for(int j=0; j&lt;szelesseg; ++j) { // s az oszlopok
      // Sejt cella kirajzolása
      if(racs[i][j] == ELO)
	qpainter.fillRect(j*cellaSzelesseg, i*cellaMagassag,
			  cellaSzelesseg, cellaMagassag, Qt::black);
	else
	  qpainter.fillRect(j*cellaSzelesseg, i*cellaMagassag,
			    cellaSzelesseg, cellaMagassag, Qt::white);
	  qpainter.setPen(QPen(Qt::gray, 1));
	
	qpainter.drawRect(j*cellaSzelesseg, i*cellaMagassag,
			  cellaSzelesseg, cellaMagassag);
    }
  }
  
  qpainter.end();
}
</programlisting></para>
        <para>A paintEvent függvény minden sejtet kirajzol, ehhez végigmegy a rácson, az élő
            sejteket feketére, a halott sejteket fehérre festi. A cella szegélyeit szürkére
            rajzolja.</para>
        <programlisting>SejtAblak::~SejtAblak()
{
  delete eletjatek;
  
  for(int i=0; i&lt;magassag; ++i) {
    delete[] racsok[0][i];
    delete[] racsok[1][i];
  }
  
  delete[] racsok[0];
  delete[] racsok[1];
  delete[] racsok;
  
  
}
</programlisting>
        <para>A destruktor törli az "eletjatek"-ot, a rácsok tartalmát, majd a rácsokat, végül a
            rácsokat eltároló tömböket
            is.<programlisting>void SejtAblak::vissza(int racsIndex)
{
  this->racsIndex = racsIndex;
  update();
}
</programlisting></para>
        <para>A vissza függvény paraméterül a racsIndexet kapja, majd ennek a változtatásávál az
            update függvénnyel frissíti az
            ablakot.<programlisting>void SejtAblak::siklo(bool **racs, int x, int y) {
  
  racs[y+ 0][x+ 2] = ELO;
  racs[y+ 1][x+ 1] = ELO;
  racs[y+ 2][x+ 1] = ELO;
  racs[y+ 2][x+ 2] = ELO;
  racs[y+ 2][x+ 3] = ELO;
  
}
</programlisting></para>
        <para>A siklót állítja elő a rácson az x és y
            segítségével.<programlisting>void SejtAblak::sikloKilovo(bool **racs, int x, int y) {
  
  racs[y+ 6][x+ 0] = ELO;
  racs[y+ 6][x+ 1] = ELO;
  racs[y+ 7][x+ 0] = ELO;
  racs[y+ 7][x+ 1] = ELO;
  
  racs[y+ 3][x+ 13] = ELO;
  
  racs[y+ 4][x+ 12] = ELO;
  racs[y+ 4][x+ 14] = ELO;
  
  racs[y+ 5][x+ 11] = ELO;
  racs[y+ 5][x+ 15] = ELO;
  racs[y+ 5][x+ 16] = ELO;
  racs[y+ 5][x+ 25] = ELO;
  
  racs[y+ 6][x+ 11] = ELO;
  racs[y+ 6][x+ 15] = ELO;
  racs[y+ 6][x+ 16] = ELO;
  racs[y+ 6][x+ 22] = ELO;
  racs[y+ 6][x+ 23] = ELO;
  racs[y+ 6][x+ 24] = ELO;
  racs[y+ 6][x+ 25] = ELO;
  
  racs[y+ 7][x+ 11] = ELO;
  racs[y+ 7][x+ 15] = ELO;
  racs[y+ 7][x+ 16] = ELO;
  racs[y+ 7][x+ 21] = ELO;
  racs[y+ 7][x+ 22] = ELO;
  racs[y+ 7][x+ 23] = ELO;
  racs[y+ 7][x+ 24] = ELO;
  
  racs[y+ 8][x+ 12] = ELO;
  racs[y+ 8][x+ 14] = ELO;
  racs[y+ 8][x+ 21] = ELO;
  racs[y+ 8][x+ 24] = ELO;
  racs[y+ 8][x+ 34] = ELO;
  racs[y+ 8][x+ 35] = ELO;
  
  racs[y+ 9][x+ 13] = ELO;
  racs[y+ 9][x+ 21] = ELO;
  racs[y+ 9][x+ 22] = ELO;
  racs[y+ 9][x+ 23] = ELO;
  racs[y+ 9][x+ 24] = ELO;
  racs[y+ 9][x+ 34] = ELO;
  racs[y+ 9][x+ 35] = ELO;
  
  racs[y+ 10][x+ 22] = ELO;
  racs[y+ 10][x+ 23] = ELO;
  racs[y+ 10][x+ 24] = ELO;
  racs[y+ 10][x+ 25] = ELO;
  
  racs[y+ 11][x+ 25] = ELO;
  
}
</programlisting></para>
        <para>Ez pedig a siklokilovo-t valósítja meg.</para>
        <para><emphasis role="bold"
            >sejtszal.cpp</emphasis><programlisting>SejtSzal::SejtSzal(bool ***racsok, int szelesseg, int magassag, int varakozas, SejtAblak *sejtAblak)
{
    this->racsok = racsok;
    this->szelesseg = szelesseg;
    this->magassag = magassag;
    this->varakozas = varakozas;
    this->sejtAblak = sejtAblak;

    racsIndex = 0;
}

</programlisting></para>
        <para>A konstruktorban megtörténik az
            értékadás.<programlisting>/**
   * Az kérdezett állapotban lévő nyolcszomszédok száma.
   *
   * @param   rács    a sejttér rács
   * @param   sor     a rács vizsgált sora
   * @param   oszlop  a rács vizsgált oszlopa
   * @param   állapor a nyolcszomszédok vizsgált állapota
   * @return int a kérdezett állapotbeli nyolcszomszédok száma.
   */
int SejtSzal::szomszedokSzama(bool **racs,
                              int sor, int oszlop, bool allapot) {
    int allapotuSzomszed = 0;
    // A nyolcszomszédok végigzongorázása:
    for(int i=-1; i&lt;2; ++i)
        for(int j=-1; j&lt;2; ++j)
            // A vizsgált sejtet magát kihagyva:
            if(!((i==0) &amp;&amp; (j==0))) {
        // A sejttérből szélének szomszédai
        // a szembe oldalakon ("periódikus határfeltétel")
        int o = oszlop + j;
        if(o &lt; 0)
            o = szelesseg-1;
        else if(o >= szelesseg)
            o = 0;

        int s = sor + i;
        if(s &lt; 0)
            s = magassag-1;
        else if(s >= magassag)
            s = 0;

        if(racs[s][o] == allapot)
            ++allapotuSzomszed;
    }

    return allapotuSzomszed;
}
</programlisting></para>
        <para>A szomszedokSzama a szomszédságból azon elemek számát adja vissza, amelyet
            megadtunk.<programlisting>/**
 * A sejttér időbeli fejlődése a John H. Conway féle
 * életjáték sejtautomata szabályai alapján történik.
 * A szabályok részletes ismertetését lásd például a
 * [MATEK JÁTÉK] hivatkozásban (Csákány Béla: Diszkrét
 * matematikai játékok. Polygon, Szeged 1998. 171. oldal.)
 */
void SejtSzal::idoFejlodes() {

    bool **racsElotte = racsok[racsIndex];
    bool **racsUtana = racsok[(racsIndex+1)%2];

    for(int i=0; i&lt;magassag; ++i) { // sorok
        for(int j=0; j&lt;szelesseg; ++j) { // oszlopok

            int elok = szomszedokSzama(racsElotte, i, j, SejtAblak::ELO);

            if(racsElotte[i][j] == SejtAblak::ELO) {
                /* Élő élő marad, ha kettő vagy három élő
             szomszedja van, különben halott lesz. */
                if(elok==2 || elok==3)
                    racsUtana[i][j] = SejtAblak::ELO;
                else
                    racsUtana[i][j] = SejtAblak::HALOTT;
            }  else {
                /* Halott halott marad, ha három élő
             szomszedja van, különben élő lesz. */
                if(elok==3)
                    racsUtana[i][j] = SejtAblak::ELO;
                else
                    racsUtana[i][j] = SejtAblak::HALOTT;
            }
        }
    }
    racsIndex = (racsIndex+1)%2;
}

</programlisting></para>
        <para>Az idoFejlodes függvény a következő rácsba tölti bele a következő időbeli állapotot,
            ehhez az egyel fentebbi függvényt is meghívja. Egy sejt akkor marad élő, ha 2 vagy 3 élő
            szomszédja van. Egy halott sejt akkor marad halott, ha 3 szomszédja van, egyébként élő
            lesz. Ezeket a vizsgálatokat elvégzi az összes sejtre, majd a racsIndex értékét
            frissítjük.<programlisting>/** A sejttér időbeli fejlődése. */
void SejtSzal::run()
{
    while(true) {
        QThread::msleep(varakozas);
        idoFejlodes();
        sejtAblak->vissza(racsIndex);
    }

}
</programlisting></para>
        <para>A run függvényben egy végtelen ciklusban az msleep segítségével a várakozást altatjuk,
            meghívjuk az időfejlődés függvényzt, és a vissza függvény segítségével az újra
            rajzolandó rácsot kapjuk vissza, ígyfrissül az
            ablak.<programlisting>SejtSzal::~SejtSzal()
{
}
</programlisting></para>
        <para>A destruktor üresen található.</para>
        <para><emphasis role="bold"
            >main.cpp</emphasis><programlisting>#include &lt;QApplication>
#include "sejtablak.h"
#include &lt;QDesktopWidget>

int main(int argc, char *argv[])
{
  QApplication a(argc, argv);
  SejtAblak w(100, 75);
  w.show();
  
  return a.exec();
}
</programlisting></para>
        <para>Hozzáadjuk a szükséges header-öket, majd egy QApplication típusú, "a" nevű változót
            hozunk létre, átadjuk neki a parancssori argumentumokat. "w" néven deklarálunk egy
            SejtAblak típusú változót, melynek méreteit megadjuk. A show függvénnyel az előbb
            elindított életjátékot mutatjuk meg a felhasználónak, a visszatérési érték az előző
            programhoz hasonlóan az "a"-nak az exec függvény által módosított értéke lesz, ami az
            ablak bezárásakor lesz 0.</para>            
    </section>        
    <section>
        <title>BrainB Benchmark</title>
        <para>
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para> Megoldás forrása: <link xlink:href=""/><link
                xlink:href="https://gitlab.com/puskasmate/bhax/tree/master/thematic_tutorials/bhax_textbook/Conway/Brain_B"
            />
        </para>
        <para>A feladatunk annyi, hogy a kurzort a Samu Entropy nevű karakteren kell tartani. Ahogy
            tellik az idő, egyre több karakter jelenik meg, így nincs egyszerű dolgunk.</para>
        <para><emphasis role="bold"
            >BrainBWin.h</emphasis><programlisting>#ifndef BrainBWin_H
#define BrainBWin_H

#include &lt;QKeyEvent>
#include &lt;QMainWindow>
#include &lt;QPixmap>
#include &lt;QPainter>
#include &lt;QFont>
#include &lt;QFile>
#include &lt;QString>
#include &lt;QCloseEvent>
#include &lt;QDate>
#include &lt;QDir>
#include &lt;QDateTime>
#include "BrainBThread.h"

enum playerstate {
    lost,
    found
};

class BrainBWin : public QMainWindow
{
    Q_OBJECT

    BrainBThread *brainBThread;
    QPixmap pixmap;
    Heroes *heroes;

    int mouse_x;
    int mouse_y;
    int yshift {50};
    int nofLost {0};
    int nofFound {0};

    int xs, ys;

    bool firstLost {false};
    bool start {false};
    playerstate state = lost;
    std::vector&lt;int> lost2found;
    std::vector&lt;int> found2lost;

    QString statDir;

public:
    static const QString appName;
    static const QString appVersion;
    BrainBWin ( int w = 256, int h = 256, QWidget *parent = 0 );

    void closeEvent ( QCloseEvent *e ) {

        if ( save ( brainBThread->getT() ) ) {
            brainBThread->finish();
            e->accept();
        } else {
            e->ignore();
        }

    }

    virtual ~BrainBWin();
    void paintEvent ( QPaintEvent * );
    void keyPressEvent ( QKeyEvent *event );
    void mouseMoveEvent ( QMouseEvent *event );
    void mousePressEvent ( QMouseEvent *event );
    void mouseReleaseEvent ( QMouseEvent *event );

    double mean ( std::vector&lt;int> vect ) {

        if ( vect.size() > 0 ) {
            double sum = std::accumulate ( vect.begin (), vect.end (), 0.0 );
            return  sum / vect.size();
        } else {
            return 0.0;
        }
    }

    double var ( std::vector&lt;int> vect, double mean ) {

        if ( vect.size() > 1 ) {

            double accum = 0.0;

            std::for_each ( vect.begin (), vect.end (), [&amp;] ( const double d ) {
                accum += ( d - mean ) * ( d - mean );
            } );

            return sqrt ( accum / ( vect.size()-1 ) );
        } else {
            return 0.0;
        }

    }

    void millis2minsec ( int millis, int &amp;min, int &amp;sec ) {

        sec = ( millis * 100 ) / 1000;
        min = sec / 60;
        sec = sec - min * 60;

    }

    bool save ( int t ) {

        bool ret = false;

        if ( !QDir ( statDir ).exists() )
            if ( !QDir().mkdir ( statDir ) ) {
                return false;
            }

        QString name = statDir + "/Test-" + QString::number ( t );
        QFile file ( name + "-screenimage.png" );
        if ( file.open ( QIODevice::WriteOnly ) ) {
            ret = pixmap.save ( &amp;file, "PNG" );
        }

        QFile tfile ( name + "-stats.txt" );
        ret = tfile.open ( QIODevice::WriteOnly | QIODevice::Text );
        if ( ret ) {
            QTextStream textStremam ( &amp;tfile );

            textStremam &lt;&lt; appName + " " + appVersion &lt;&lt; "\n";
            textStremam &lt;&lt; "time      : " &lt;&lt;  brainBThread->getT() &lt;&lt; "\n";
            textStremam &lt;&lt; "bps       : " &lt;&lt;  brainBThread->get_bps() &lt;&lt; "\n";
            textStremam &lt;&lt; "noc       : " &lt;&lt;  brainBThread->nofHeroes() &lt;&lt; "\n";
            textStremam &lt;&lt; "nop       : " &lt;&lt;  brainBThread->get_nofPaused() &lt;&lt; "\n";

            textStremam &lt;&lt; "lost      : "  &lt;&lt; "\n";
            std::vector&lt;int> l = brainBThread->lostV();
            for ( int n : l ) {
                textStremam &lt;&lt; n &lt;&lt; ' ';
            }
            textStremam &lt;&lt;  "\n";
            int m = mean ( l );
            textStremam &lt;&lt; "mean      : " &lt;&lt;  m &lt;&lt; "\n";
            textStremam &lt;&lt; "var       : " &lt;&lt;  var ( l, m ) &lt;&lt; "\n";

            textStremam &lt;&lt; "found     : " ;
            std::vector&lt;int> f = brainBThread->foundV();
            for ( int n : f ) {
                textStremam &lt;&lt; n &lt;&lt; ' ';
            }
            textStremam &lt;&lt;  "\n";
            m = mean ( f );
            textStremam &lt;&lt; "mean      : " &lt;&lt;  m &lt;&lt; "\n";
            textStremam &lt;&lt; "var       : " &lt;&lt;  var ( f, m ) &lt;&lt; "\n";

            textStremam &lt;&lt; "lost2found: "  ;
            for ( int n : lost2found ) {
                textStremam &lt;&lt; n &lt;&lt; ' ';
            }
            textStremam &lt;&lt;  "\n";
            int m1 = m = mean ( lost2found );
            textStremam &lt;&lt; "mean      : " &lt;&lt;  m &lt;&lt; "\n";
            textStremam &lt;&lt; "var       : " &lt;&lt;  var ( lost2found, m ) &lt;&lt; "\n";

            textStremam &lt;&lt; "found2lost: "  ;
            for ( int n : found2lost ) {
                textStremam &lt;&lt; n &lt;&lt; ' ';
            }
            textStremam &lt;&lt;  "\n";
            int m2 = m = mean ( found2lost );
            textStremam &lt;&lt; "mean      : " &lt;&lt;  m &lt;&lt; "\n";
            textStremam &lt;&lt; "var       : " &lt;&lt;  var ( found2lost, m ) &lt;&lt; "\n";

            if ( m1 &lt; m2 ) {
                textStremam &lt;&lt; "mean(lost2found) &lt; mean(found2lost)" &lt;&lt; "\n";
            }

            int min, sec;
            millis2minsec ( t, min, sec );
            textStremam &lt;&lt; "time      : " &lt;&lt;  min  &lt;&lt; ":"  &lt;&lt; sec &lt;&lt; "\n";

            double res = ( ( ( ( double ) m1+ ( double ) m2 ) /2.0 ) /8.0 ) /1024.0;
            textStremam &lt;&lt; "U R about " &lt;&lt; res &lt;&lt; " Kilobytes\n";

            tfile.close();
        }
        return ret;
    }

public slots :

    void updateHeroes ( const QImage &amp;image, const int &amp;x, const int &amp;y );
    //void stats ( const int &amp;t );
    void endAndStats ( const int &amp;t );
};

#endif // BrainBWin</programlisting>Tartalmaz
            egy konstruktort, egy destruktort, olyan függvényeket, amelyek az inputról beérkező
            jeleket figyelik. A kirajzolásért felelős függvények is itt vannak, illetve az ablak
            frissítéséért felelős függvények, valamint egy mentésért felelős függvényt is
            definiáltunk.</para>
        <para><emphasis role="bold"
            >BrainBWin.cpp</emphasis><programlisting>#include "BrainBWin.h"

const QString BrainBWin::appName = "NEMESPOR BrainB Test";
const QString BrainBWin::appVersion = "6.0.3";

BrainBWin::BrainBWin ( int w, int h, QWidget *parent ) : QMainWindow ( parent )
{

//    setWindowTitle(appName + " " + appVersion);
//    setFixedSize(QSize(w, h));

        statDir = appName + " " + appVersion + " - " + QDate::currentDate().toString() + QString::number ( QDateTime::currentMSecsSinceEpoch() );

        brainBThread = new BrainBThread ( w, h - yshift );
        brainBThread->start();

        connect ( brainBThread, SIGNAL ( heroesChanged ( QImage, int, int ) ),
                  this, SLOT ( updateHeroes ( QImage, int, int ) ) );

        connect ( brainBThread, SIGNAL ( endAndStats ( int ) ),
                  this, SLOT ( endAndStats ( int ) ) );

}

void BrainBWin::endAndStats ( const int &amp;t )
{

        qDebug()  &lt;&lt; "\n\n\n";
        qDebug()  &lt;&lt; "Thank you for using " + appName;
        qDebug()  &lt;&lt; "The result can be found in the directory " + statDir;
        qDebug()  &lt;&lt; "\n\n\n";

        save ( t );
        close();
}

void BrainBWin::updateHeroes ( const QImage &amp;image, const int &amp;x, const int &amp;y )
{

        if ( start &amp;&amp; !brainBThread->get_paused() ) {

                int dist = ( this->mouse_x - x ) * ( this->mouse_x - x ) + ( this->mouse_y - y ) * ( this->mouse_y - y );

                if ( dist > 121 ) {
                        ++nofLost;
                        nofFound = 0;
                        if ( nofLost > 12 ) {

                                if ( state == found &amp;&amp; firstLost ) {
                                        found2lost.push_back ( brainBThread->get_bps() );
                                }

                                firstLost = true;

                                state = lost;
                                nofLost = 0;
                                //qDebug() &lt;&lt; "LOST";
                                //double mean = brainBThread->meanLost();
                                //qDebug() &lt;&lt; mean;

                                brainBThread->decComp();
                        }
                } else {
                        ++nofFound;
                        nofLost = 0;
                        if ( nofFound > 12 ) {

                                if ( state == lost &amp;&amp; firstLost ) {
                                        lost2found.push_back ( brainBThread->get_bps() );
                                }

                                state = found;
                                nofFound = 0;
                                //qDebug() &lt;&lt; "FOUND";
                                //double mean = brainBThread->meanFound();
                                //qDebug() &lt;&lt; mean;

                                brainBThread->incComp();
                        }

                }

        }
        pixmap = QPixmap::fromImage ( image );
        update();
}

void BrainBWin::paintEvent ( QPaintEvent * )
{
        if ( pixmap.isNull() ) {
                return;
        }

        QPainter qpainter ( this );

        xs = ( qpainter.device()->width() - pixmap.width() ) /2;
        ys = ( qpainter.device()->height() - pixmap.height() +yshift ) /2;

        qpainter.drawPixmap ( xs, ys, pixmap );

        qpainter.drawText ( 10, 20, "Press and hold the mouse button on the center of Samu Entropy" );

        int time = brainBThread->getT();
        int min, sec;
        millis2minsec ( time, min, sec );
        QString timestr = QString::number ( min ) + ":" + QString::number ( sec ) + "/10:0";
        qpainter.drawText ( 10, 40, timestr );

        int bps = brainBThread->get_bps();
        QString bpsstr = QString::number ( bps ) + " bps";
        qpainter.drawText ( 110, 40, bpsstr );

        if ( brainBThread->get_paused() ) {
                QString pausedstr = "PAUSED (" + QString::number ( brainBThread->get_nofPaused() ) + ")";

                qpainter.drawText ( 210, 40, pausedstr );
        }

        qpainter.end();
}

void BrainBWin::mousePressEvent ( QMouseEvent *event )
{

        brainBThread->set_paused ( false );

}

void BrainBWin::mouseReleaseEvent ( QMouseEvent *event )
{

        //brainBThread->set_paused(true);

}

void BrainBWin::mouseMoveEvent ( QMouseEvent *event )
{

        start = true;

        mouse_x = event->pos().x() -xs - 60;
        //mouse_y = event->pos().y() - yshift - 60;
        mouse_y = event->pos().y() - ys - 60;
}

void BrainBWin::keyPressEvent ( QKeyEvent *event )
{

        if ( event->key() == Qt::Key_S ) {
                save ( brainBThread->getT() );
        } else if ( event->key() == Qt::Key_P ) {
                brainBThread->pause();
        } else if ( event->key() == Qt::Key_Q ||  event->key() == Qt::Key_Escape ) {
                close();
        }

}

BrainBWin::~BrainBWin()
{

}</programlisting></para>
        <para>Ebben a programban magyarázzuk meg a fentebbi header-ben deklarált dolgokat.</para>
        <para><emphasis role="bold"
            >BrainBThread.h</emphasis><programlisting>#ifndef BrainBThread_H
#define BrainBThread_H

#include &lt;QThread>
#include &lt;QSize>
#include &lt;QImage>
#include &lt;QDebug>
#include &lt;sstream>
#include &lt;QPainter>
#include &lt;cstdlib>
#include &lt;ctime>
#include &lt;vector>
#include &lt;opencv2/opencv.hpp>
#include &lt;opencv2/core/core.hpp>
#include &lt;opencv2/imgproc/imgproc.hpp>

class Hero;
typedef std::vector&lt;Hero> Heroes;

class Hero
{

public:
    int x;
    int y;
    int color;
    int agility;
    int conds {0};
    std::string name;

    Hero ( int x=0, int  y=0, int color=0, int agility=1,  std::string name ="Samu Entropy" ) :
        x ( x ), y ( y ), color ( color ), agility ( agility ), name ( name )
    {}
    ~Hero() {}

    void move ( int maxx, int maxy, int env ) {

        int newx = x+ ( ( ( double ) agility*1.0 ) * ( double ) ( std::rand() / ( RAND_MAX+1.0 ) )-agility/2 ) ;
        if ( newx-env > 0 &amp;&amp; newx+env &lt; maxx ) {
            x = newx;
        }
        int newy = y+ ( ( ( double ) agility*1.0 ) * ( double ) ( std::rand() / ( RAND_MAX+1.0 ) )-agility/2 );
        if ( newy-env > 0 &amp;&amp; newy+env &lt; maxy ) {
            y = newy;
        }

    }

};

class BrainBThread : public QThread
{
    Q_OBJECT

    
     //Norbi
    cv::Scalar cBg { 247, 223, 208 };
    cv::Scalar cBorderAndText { 47, 8, 4 };
    cv::Scalar cCenter { 170, 18, 1 };
    cv::Scalar cBoxes { 10, 235, 252 };
    

    /*
    //Matyi
    cv::Scalar cBg { 86, 26, 228 };
    cv::Scalar cBorderAndText { 14, 177, 232 };
    cv::Scalar cCenter { 232, 14, 103 };
    cv::Scalar cBoxes { 14, 232, 195 };
*/
    
    Heroes heroes;
    int heroRectSize {40};

    cv::Mat prev {3*heroRectSize, 3*heroRectSize, CV_8UC3, cBg };
    int bps;
    long time {0};
    long endTime {10*60*10};
    int delay {100};

    bool paused {true};
    int nofPaused {0};

    std::vector&lt;int> lostBPS;
    std::vector&lt;int> foundBPS;

    int w;
    int h;
    int dispShift {40};

public:
    BrainBThread ( int w = 256, int h = 256 );
    ~BrainBThread();

    void run();
    void pause();
    void set_paused ( bool p );
    int getDelay() const {

        return delay;

    }
    void setDelay ( int delay ) {

        if ( delay > 0 ) {
            delay = delay;
        }

    }

    void devel() {

        for ( Hero &amp; hero : heroes ) {

            hero.move ( w, h, ( h&lt;w ) ?h/10:w/10 );

        }

    }

    int nofHeroes () {

        return  heroes.size();

    }

    std::vector&lt;int> &amp;lostV () {

        return  lostBPS;

    }

    std::vector&lt;int> &amp;foundV () {

        return  foundBPS;

    }

    double meanLost () {

        return  mean ( lostBPS );

    }

    double varLost ( double mean ) {

        return  var ( lostBPS, mean );

    }

    double meanFound () {

        return  mean ( foundBPS );

    }

    double varFound ( double mean ) {

        return  var ( foundBPS, mean );

    }

    double mean ( std::vector&lt;int> vect ) {

        double sum = std::accumulate ( vect.begin (), vect.end (), 0.0 );
        return  sum / vect.size();

    }

    double var ( std::vector&lt;int> vect, double mean ) {

        double accum = 0.0;
        std::for_each ( vect.begin (), vect.end (), [&amp;] ( const double d ) {
            accum += ( d - mean ) * ( d - mean );
        } );

        return sqrt ( accum / ( vect.size()-1 ) );
    }

    int get_bps() const {

        return bps;

    }

    int get_w() const {

        return w;

    }


    bool get_paused() const {

        return paused;

    }

    int get_nofPaused() const {

        return nofPaused;

    }

    void decComp() {

        lostBPS.push_back ( bps );

        if ( heroes.size() > 1 ) {
            heroes.pop_back();
        }

        for ( Hero &amp; hero : heroes ) {
            if ( hero.agility >= 5 ) {
                hero.agility -= 2;
            }

        }

    }

    void incComp() {

        foundBPS.push_back ( bps );

        if ( heroes.size() > 300 ) {

            return;

        }

        /*
        Hero other ( w/2 + 200.0*std::rand() / ( RAND_MAX+1.0 )-100,
                     h/2 + 200.0*std::rand() / ( RAND_MAX+1.0 )-100,
                     255.0*std::rand() / ( RAND_MAX+1.0 ), 11, "New Entropy" );
                     */

	double rx = 200.0;
	if(heroes[0].x - 200 &lt; 0)
	  rx = heroes[0].x;
	else if(heroes[0].x + 200 > w)
	  rx = w - heroes[0].x;
	
	double ry = 200.0;
	if(heroes[0].y - 200 &lt; 0)
	  ry = heroes[0].y;
	else if(heroes[0].y + 200 > h)
	  ry = h - heroes[0].y;
	
        Hero other ( heroes[0].x + rx*std::rand() / ( RAND_MAX+1.0 )-rx/2,
                     heroes[0].y + ry*std::rand() / ( RAND_MAX+1.0 )-ry/2,
                     255.0*std::rand() / ( RAND_MAX+1.0 ), 11, "New Entropy" );
		
        heroes.push_back ( other );

        for ( Hero &amp; hero : heroes ) {

            ++hero.conds;
            if ( hero.conds == 3 ) {
                hero.conds = 0;
                hero.agility += 2;
            }

        }

    }

    void draw () {

        cv::Mat src ( h+3*heroRectSize, w+3*heroRectSize, CV_8UC3, cBg );

        for ( Hero &amp; hero : heroes ) {

            cv::Point x ( hero.x-heroRectSize+dispShift, hero.y-heroRectSize+dispShift );
            cv::Point y ( hero.x+heroRectSize+dispShift, hero.y+heroRectSize+dispShift );

            cv::rectangle ( src, x, y, cBorderAndText );

            cv::putText ( src, hero.name, x, cv::FONT_HERSHEY_SIMPLEX, .35, cBorderAndText, 1 );

            cv::Point xc ( hero.x+dispShift , hero.y+dispShift );

            cv::circle ( src, xc, 11, cCenter, CV_FILLED, 8, 0 );

            cv::Mat box = src ( cv::Rect ( x, y ) );

            cv::Mat cbox ( 2*heroRectSize, 2*heroRectSize, CV_8UC3, cBoxes );
            box = cbox*.3 + box*.7;

        }

        cv::Mat comp;

        cv::Point focusx ( heroes[0].x- ( 3*heroRectSize ) /2+dispShift, heroes[0].y- ( 3*heroRectSize ) /2+dispShift );
        cv::Point focusy ( heroes[0].x+ ( 3*heroRectSize ) /2+dispShift, heroes[0].y+ ( 3*heroRectSize ) /2+dispShift );
        cv::Mat focus = src ( cv::Rect ( focusx, focusy ) );

        cv::compare ( prev, focus, comp, cv::CMP_NE );

        cv::Mat aRgb;
        cv::extractChannel ( comp, aRgb, 0 );

        bps = cv::countNonZero ( aRgb ) * 10;

        //qDebug()  &lt;&lt; bps &lt;&lt; " bits/sec";

        prev = focus;

        QImage dest ( src.data, src.cols, src.rows, src.step, QImage::Format_RGB888 );
        dest=dest.rgbSwapped();
        dest.bits();

        emit heroesChanged ( dest, heroes[0].x, heroes[0].y );

    }

    long getT() const {

        return time;

    }

    void finish () {

        time = endTime;

    }


signals:

    void heroesChanged ( const QImage &amp;image, const int &amp;x, const int &amp;y );
    void endAndStats ( const int &amp;t );

};

#endif // BrainBThread_H</programlisting></para>            
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
